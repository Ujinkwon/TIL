# 서로소 집합 (Disjoint-sets)
* 서로소 or 상호배타 집합 : 서로 중복 포함된 원소가 없는 집합들
* 대표자 : 각 집합을 구분하는 집합에 속한 하나의 특정 멤버

## 연결 리스트 
* 같은 집합의 원소들은 하나의 연결리스트로 관리
* 맨 앞의 원소를 집합의 대표 원소로 삼음
* 각 원소는 집합의 대표원소를 가리키는 링크를 가짐

## 트리
* 하나의 집합을 하나의 트리로 표현
* 자식 노드가 부모 노드를 가리키고 대표자는 루트 노드

* 상호배타 집합 연산 
  * Make-Set(x) : 유일한 멤버 x를 포함하는 새로운 집합 생성
  * Find-Set(x) : x를 포함하는 집합을 찾는 연산
  * Union(x, y) : x와 y를 포함하는 두 집합을 통합하는 연산

```python
def make_set(x):
  p[x] = x   

def find_set(x):
  if x == p[x]:
    return x
  else:
    find_set(p[x])

def union(x, y):
  p[find_set(y)] = find_set(x)
```
* 연산의 효율을 높이는 방법
  * rank를 이용한 union
    * 자신을 루트로 하는 서브트리의 높이를 rank라는 이름으로 저장
    * 두 집합을 합칠 때 rank가 낮은 집합을 높은 집합에 붙임
  * path compression
    * find-set 과정에서 만나는 모든 노드들이 직접 루트를 가리키도록 포인터를 바꿔줌

```python
def make_set(x):
  p[x] = x   # 노드 x의 부모 저장
  rank[x] = 0   # 루트 노드가 x인 트리의 랭크 값 저장

def find_set(x):
  if x != p[x]:  # x가 루트가 아닌 경우
    p[x] = find_set(p[x])
  return p[x]

def union(x, y):
  link(find_set(x), find_set(y))

def link(x, y):
  if rank[x] > rank[y]:   # rank : 트리 높이
    p[y] = x
  else:
    p[x] = y
    if rank[x] == rank[y]:
      rank[y] += 1
```

# 최소 비용 신장 트리 (MST)
* 신장 트리 : n개의 정점으로 이뤄진 무방향 그래프에서 n개의 정점과 n-1개의 간선으로 이뤄진 트리
* 최소 신장 트리 : 무방향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치 합이 최소인 신장 트리

# Prim 알고리즘
* 하나의 정점에서 연결된 간선들 중에 하나씩 선택하면서 MST를 만들어 가는 방식
  * 임의 정점 하나 선택
  * 선택한 정점과 인접 정점 중 최소 비용의 간선이 존재하는 정점 선택
  * 모든 정점이 선택될 때 까지 반복
* 서로소인 2개의 집합 정보 유지
  * 트리 정점들 : MST 만들기 위해 선택된 정점들
  * 비트리 정점들 : 선택되지 않은 정점들

# KRUSKAL 알고리즘
* 간선을 하나씩 선택해서 MST를 찾는 알고리즘
  * 최초, 모든 간선을 가중치에 따라 `오름차순`으로 정렬
  * 가중치가 가장 낮은 간선부터 선택하면서 트리 증가
    * 사이클 존재 시, 가중치가 다음으로 낮은 간선 선택
  * n-1개 간선이 선택될 때 까지 반복

# 최단 경로
* 간선의 가중치가 있는 그래프에서 간선의 가중치의 합이 최소인 경로
* 시작 정점에서 끝 정점까지의 최단 경로
  * 다익스트라 알고리즘 : 음의 가중치 허용 x
  * 벨만-포드 알고리즘 : 음의 가중치 허용 o
* 모든 정점들에 대한 최단 경로
  * 플로이드-워샬 알고리즘
## Dijkstra 알고리즘
