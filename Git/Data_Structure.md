# 데이터 구조

* 데이터 구조를 활용하기 위해서는 메서드(method)를 활용
  
  * 메서드는 클래스 내부에 정의한 함수, 사실상 함수 동일
  * 객체의 기능

* 데이터 구조.메서드()

* 파이썬 공식 문서의 표기법(배커스-나우르 표기법)
  
  * 컴퓨터 언어에서 문법을 수학적인 수식으로 나타낼 때 사용하는 언어 도구
  * 프로그래밍 언어의 구문을 기술하는 데 자연스러운 표기법
    * str.replace(old, new[,count])
    * old, new는 필수 / [,count]는 선택적 인자
  
  # 순서가 있는 데이터 구조
  
  ## 문자열(String)

* 모든 문자는 str 타입(변경 불가능한 immutable)

* 문자열은 작은 따옴표나 큰 따옴표를 활용하여 표기
  
  * 묶을 때 동일한 문장부호를 활용
  * PEP8에서는 소스코드 내에서 하나의 문장부호를 선택하여 유지

* 문자열 조회/탐색 및 검증 메서드
  
  * s.find(x) : x의 첫 번째 위치를 반환. 없으면 -1을 반환
  * s.index(x) : x의 첫 번째 위치를 반환. 없으면 오류 발생
  * s.isalpha() : 알파벳 문자 여부 (유니코드 상 letter, 한국어 포함)
  * s.isupper() : 대문자 여부
  * s.islower() : 소문자 여부
  * s.istitle() : 타이틀 형식 여부

* 문자열 변경 메서드(s는 문자열)
  
  * s.replace(old, new[,count]) : 바꿀 대상 글자를 새로운 글자로 바꿔서 반환
  * s.strip([chars]) : 공백이나 특장 문자를 제거
    * 양쪽 제거(strip) / 왼쪽 제거(lstrip) / 오른쪽 제거(rstrip)
  * s.split(sep=None, maxsplit=-1) : 공백이나 특정 문자를 기준으로 분리
  * 'separator'.join([iterable]) : 구분자로 iterable을 합침
  * s.capitalize() : 가장 첫 번째 글자를 대문자로 변경
  * s.title() : 문자열 내 띄어쓰기 기준으로 각 단어의 첫글자는 대문자로, 나머지는 소문자로 변환
  * s.upper() : 모두 대문자로 변경
  * s.lower() : 모두 소문자로 변경
  * s.swqpcase() : 대<->소문자 서로 변경

* 문자열은 기존의 것을 변경하는 게 아니라, 변경된 문자열을 새롭게 만들어서 반환

* ![](Data_Structure_assets/2022-07-26-09-59-14-image.png)
  
  ## 리스트(List)

* 여러 개의 값을 순서가 있는 구조로 저장하고 싶을 때 사용

* 대괄호 or list()를 통해 생성
  
  * 어떠한 자료형도 저장 가능, 리스트 안에 리스트도 가능
  * 생성 이후 내용 변경 가능 => 가변 자료형

* 순서가 있는 시퀀스로 인덱스를 통해 접근 가능

* 리스트 메서드
  * L.append(x) : 리스트 마지막에 항목 x를 추가
  * L.insert(i, x) : 리스트 인덱스 i에 항목 x를 추가
  * L.remove(x) : 리스트 가장 왼쪽에 있는 항목 x를 제거, 존재하지 않을 경우(ValueError)
  * L.pop() : 리스트 가장 오른쪽에 있는 항목을 반환 후 제거
  * L.pop(i) : 리스트의 인덱스 i에 있는 항목을 반환 후 제거
  * L.extend(m) : 순회형 m의 모든 항목들의 리스트 끝에 추가(+=)
  * L.index(x, start, end) : 리스트에 있는 항목 중 가장 왼쪽에 있는 항목 x의 인덱스를 반환 (없는 경우 ValueError)
  * L.reverse() : 순서를 반대로 뒤집음(정렬하는 것이 아님)
  * L.sort() : 원본 리스트를 정렬(매개변수 이용가능) / None 반환
  * L.sorted() : 정렬된 리스트를 반환, 원본 변경 없음
  * L.count(x) : 리스트에서 항목 x가 몇 개 존재하는지 갯수 반환
  * L.clear() :  모든 항목 삭제
    
    ## 튜플(Tuple)
    * 튜플은 여러 개의 값을 순서가 있는 구조로 저장하고 싶을 때 사용
    * 리스트와 다르게 담고 있는 값 변경 불가 => 불변 자료형
    * 항상 소괄호 형태로 사용
    * 튜플은 변경 불가능하므로 값에 영향을 미치지 않는 메서드만을 지원
    * 리스트 메서드 중 항목 변경 메서드 제외, 대부분 동일
  
  # 순서가 없는 데이터 구조
  
  ## 셋(Set)
  * 중복되는 요소 없이, 순서에 상관없는 데이터들의 묶음
    * 데이터 중복을 허용하지 않기 때문에 중복 원소는 하나만 저장
    * 순서가 없으므로 인덱스 접근 불가능
  * 수학에서 집합을 표현한 컨테이너
    * 집합 연산 가능(여집합 표현하는 연산자 X)
  * 담고 있는 요소를 삽입 변경, 삭제 가능 => 가변 자료형(mutable)
  * 셋 메서드
    * s.copy() : 셋의 얕은 복사본 반환
    * s.add(x) : 항목 x가 셋 s에 없다면 추가
    * s.pop() : 셋s에서 랜덤하게 항목을 반환하고, 해당 항목을 제거(셋이 비어있을 경우 KeyError)
    * s.remove(x) : 항목 x를 셋 s에서 삭제 (항목이 존재하지 않을 경우 KeyError)
    * s.discard(x) : 항목 x가 셋 s에 있는 경우, 항목 x를 셋 s에서 삭제 (항목이 존재하지 않아도 에러 발생 X)
    * s.update(t) : 셋 t에 있는 모든 항목 중 셋 s에 없는 항목 추가(여러 값을 추가)
    * s.clear() :  모든 항목 제거
    * s.isdisjoint(t) : 셋 s가 셋 t의 서로 같은 항목을 하나라도 갖고 있지 않은 경우, True 반환
    * s.issubset(t) : 셋 s가 셋 t의 하위 셋인 경우, True 반환
    * s.issuperset(t) :  셋 s가 셋 t의 상위 셋인 경우, True 반환
  
  ## 딕셔너리(Dictionary)
  * Key-Value 쌍으로 이뤄진 자료형
  * Key는 변경 불가능한 데이터(immutable)만 활용 가능
    * string, integer, float, boolean, tuple, range
  * 딕셔너리 메서드
    * d.clear() : 모든 항목 제거
    * d.copy() : 딕셔너리 d의 얕은 복사본 반환
    * d.keys() : 딕셔너리 d의 모든 키를 담은 뷰를 반환
    * d.values() : 딕셔너리 d의 모든 값을 담은 뷰를 반환
    * d.items() : 딕셔너리 d의 모든 키-값 쌍을 담은 뷰를 반환
    * d.get(k) : 키 k의 값을 반환하는데, 키 k가 딕셔너리 d에 없을 경우 v를 반환
    * d.get(k, v) : 키 k의 값을 반환하고, 키 k인 항목을 딕셔너리 d에서 삭제하는데, 키 k가 딕셔너리 d에 없을 경우 KeyError
    * d.pop(k) : 키 k의 값을 반환하고, 키 k인 항목을 딕셔너리 d에서 삭제하는데, 키 k가 딕셔너리 d에 없을 경우 KeyError
    * d.pop(k, v) : 키 k의 값을 반환하고 키 k인 항목을 딕셔너리 d에서 삭제하는데, 키 k가 딕셔너리 d에 없을 경우 v를 반환
    * d.update([other]) : 딕셔너리 d의 값을 매핑하여 업데이트
  
  # 얕은 복사와 깊은 복사
  ## 할당(assignment)
    * 대입 연산자(=) : 대입 연산자를 통한 복사는 해당 객체에 대한 객체 참조를 복사
   ```python
   original_list = [1, 2, 3]
   copy_list = original_list
   print(original_list, copy_list)   # [1, 2, 3] [1, 2, 3]

   copy_list[0] = 'hello'
   print(original_list, copy_list)   # ['hello', 2, 3] ['hello', 2, 3]
   # 해당 주소의 일부 값을 변경하는 경우 이를 참조하는 모든 변수에 영향
   ```

  ## 얕은 복사(shallow copy)
    * 슬라이스 연산자를 활용하여 같은 원소를 가진 리스트지만 연산된 결과를 복사 (다른 주소)
   ```python
   a = [1, 2, 3]
   b = a[:]
   print(a, b)     # [1, 2, 3] [1, 2, 3]
   b[0] = 5
   print(a, b)     # [1, 2, 3] [5, 2, 3]
   ```
   ```python
   # 복사하는 리스트의 원소가 주소를 참조하는 경우
   a = [1, 2, ['a', 'b']]
   b = a[:]
   print(a, b)     # [1, 2, ['a', 'b']] [1, 2, ['a', 'b']]
   b[2][0] = 0
   pritn(a, b)     # [1, 2, [0, 'b']] [1, 2, [0, 'b']]
   ```

   ## 깊은 복사(deep copy)
   ``` python
   import copy
   a = [1, 2, ['a', 'b']]
   b = copy.deepcopy(a)
   print(a, b)      # [1, 2, ['a', 'b']] [1, 2, ['a', 'b']]
   b[2][0]
   print(a, b)      # [1, 2, ['a', 'b']] [1, 2, [0, 'b']]
   ```

   * 할당 : 다른 변수에 할당하였지만, 리스트는 하나
   * 복사 : 리스트가 각각 생성
   * 튜플은 할당에는 문제가 없지만, 복사를 하면 에러 발생 => 불변 객체기 때문
   * 얕은 복사 : 리스트 안의 리스트는 할당했을 때처럼 같은 리스트를 가짐 (다른 인덱스는 리스트가 따로 생성) 결국 얕은 복사는 가장 바깥에 있는 껍질만 복사하는 것
   * 깊은 복사 : 안쪽 요소들까지 복사를 하고 싶을 때 사용 
 